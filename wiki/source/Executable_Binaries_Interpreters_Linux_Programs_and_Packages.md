# بررسی علمی: حالت اجرایی در زبان‌ها، عملکرد فایل‌های اجرایی در لینوکس، و تفاوت برنامه و پکیج

در این مقاله تخصصی به تحلیل عمیق موضوعاتی همچون ضرورت تبدیل زبان‌های برنامه‌نویسی به حالت اجرایی، نحوه اجرای برنامه‌ها در لینوکس، تفاوت "باینری" و "پکیج"، و نحوه شروع اجرای فایل‌های اجرایی بدون پسوند می‌پردازیم.

---

## ✅ آیا تمام زبان‌های برنامه‌نویسی باید به حالت اجرایی برسند؟

### بله، به‌نوعی **تمام زبان‌های برنامه‌نویسی برای اجرا باید به شکل قابل درک توسط ماشین** تبدیل شوند — ولی این تبدیل می‌تواند به سه روش صورت گیرد:

| روش اجرا                        | توضیح                                 | مثال زبان‌ها                             |
| ------------------------------- | ------------------------------------- | ---------------------------------------- |
| **کامپایل به کد ماشین**         | مستقیم به باینری تبدیل می‌شود         | C, C++, Rust                             |
| **تفسیر (Interpretation)**      | خط به خط توسط مفسر اجرا می‌شود        | Python, Ruby, Bash                       |
| **کامپایل به Bytecode / واسطه** | تبدیل به یک زبان میانی و اجرا توسط VM | Java (bytecode → JVM), C# (.NET CLR), Go |

بنابراین، **تمام زبان‌ها در نهایت باید به چیزی برسند که CPU یا ماشین مجازی قادر به اجرای آن باشد**. این حالت می‌تواند باینری واقعی یا کد میانی باشد.

---

## 🧠 برنامه‌ها در لینوکس چگونه کار می‌کنند؟

در لینوکس، وقتی یک فایل اجرایی (مثلاً ELF) اجرا می‌شود، فرآیند زیر طی می‌شود:

### 🔍 مرحله اول: شناسایی فایل اجرایی

* فایل اجرایی باید **قابل اجرا (Executable)** باشد: مجوز اجرایی (با `chmod +x`) لازم است.
* کرنل لینوکس با استفاده از **Header فایل** (معمولاً ELF header: `0x7F 'E' 'L' 'F'`) نوع فایل را تشخیص می‌دهد.

### ⚙️ مرحله دوم: بارگذاری توسط Loader سیستم

* Loader لینوکس (مثل `/lib/ld-linux.so.2`) مسئول بارگذاری فایل در حافظه است.
* بخش‌های `.text`, `.data`, `.bss`, `.rodata` در RAM map می‌شوند.
* جدول Dynamic Linking (در صورت وجود) بررسی می‌شود و کتابخانه‌های لازم مانند libc.so بارگذاری می‌شوند.

### 🧩 مرحله سوم: انتقال کنترل به Entry Point

* کنترل از کرنل به نقطه ورودی (Entry Point) فایل منتقل می‌شود.
* این نقطه معمولاً تابع `main` یا معادل آن در سطح پایین (مانند `_start`) است.

---

## ⚡ چرا به فایل‌های اجرایی «باینری» می‌گویند؟

واژه‌ی **"باینری"** به این دلیل استفاده می‌شود که این فایل‌ها به‌صورت **داده‌های دودویی (۰ و ۱)** هستند که مستقیماً توسط CPU تفسیر می‌شوند، برخلاف سورس‌کد که متنی است.

> در **مفسرها** (مانند Python)، فایل اصلی سورس‌کد متنی است، و **مفسر** خودش باینری است که سورس‌کد را اجرا می‌کند. بنابراین **اصطلاح "باینری" برای مفسرها کاربرد مستقیم ندارد** اما مفسر خودش یک باینری است.

---

## 📦 تفاوت بین "پکیج" و "برنامه" چیست؟

| مفهوم                | تعریف                                                    | مثال                            |
| -------------------- | -------------------------------------------------------- | ------------------------------- |
| **برنامه (Program)** | مجموعه‌ای از فایل‌های اجرایی و منابع برای انجام یک وظیفه | Firefox, GIMP, Telegram         |
| **پکیج (Package)**   | قالب‌بندی استاندارد برای توزیع، نصب و مدیریت برنامه      | `.deb`, `.rpm`, `.apk`, `.snap` |

### ✅ نتیجه:

* **پکیج عام‌تر است** چون شامل برنامه و وابستگی‌های آن است.
* یک برنامه می‌تواند از طریق چند نوع پکیج ارائه شود.

---

## 🧩 انواع پکیج‌ها (در پلتفرم‌های مختلف)

| پلتفرم        | نوع پکیج                         | توضیح                       |
| ------------- | -------------------------------- | --------------------------- |
| Debian/Ubuntu | `.deb`                           | فرمت dpkg                   |
| RedHat/Fedora | `.rpm`                           | فرمت RPM                    |
| Arch Linux    | `.pkg.tar.zst`                   | فرمت pacman                 |
| Android       | `.apk`                           | شامل فایل DEX و منابع XML   |
| Java          | `.jar`                           | بایت‌کد JVM                 |
| Windows       | `.msi`, `.exe`, `.appx`          | Installer و Package formats |
| Universal     | `.snap`, `.flatpak`, `.AppImage` | پکیج‌های کراس‌توزیع         |

### Android: `.apk` = Zip archive شامل:

* `classes.dex` → فایل DEX (Dalvik Executable)
* `AndroidManifest.xml`, منابع، کتابخانه‌ها

> بله، درست می‌فرمایید: در اندروید فایل `.apk` در واقع بسته‌ای از DEXهاست که توسط ماشین مجازی Android Runtime (ART یا Dalvik) اجرا می‌شوند.

---

## 🚀 اجرای فایل اجرایی بدون پسوند در لینوکس چگونه است؟

فرض کنید فایلی مثل `telegram` را دانلود کرده‌اید و این فایل هیچ پسوندی ندارد:

### فرآیند اجرا:

1. **بررسی مجوز اجرایی**:

   ```bash
   chmod +x telegram
   ```
2. **اجرای مستقیم**:

   ```bash
   ./telegram
   ```

### کرنل چه می‌کند؟

* کرنل هدر فایل را بررسی می‌کند:

  * اگر ELF باشد، loader آن را با `/lib/ld-linux.so` اجرا می‌کند.
  * اگر script باشد (با `#!`)، به مفسر مربوطه (مثلاً `#!/usr/bin/python3`) تحویل می‌دهد.

---

## 🔎 چگونه بفهمیم با چه زبانی کامپایل شده؟

برای تشخیص اطلاعات اجرایی:

```bash
file telegram
readelf -h telegram
strings telegram | grep "GCC"
```

* معمولاً در بخشی از فایل یا در symbol table اشاره‌هایی به کامپایلر (GCC, Clang, Go, Rust) وجود دارد.

---

## 📲 آیا تلگرام رسمی لینوکس وجود دارد؟ غیررسمی‌ها چطور؟

### تلگرام رسمی برای لینوکس:

* بله، در [سایت رسمی Telegram](https://desktop.telegram.org) نسخه رسمی برای لینوکس ارائه می‌شود که به‌صورت باینری است و مستقیماً اجرا می‌شود.
* شامل فایل اجرایی با فرمت ELF و بدون پسوند خاص.

### نسخه‌های غیررسمی:

* بله، نسخه‌های غیررسمی متن‌باز زیادی وجود دارند، مانند:

  * **Kotatogram**: مبتنی بر Telegram Desktop با ویژگی‌های افزوده
  * **Telegram CLI**: نسخه ترمینالی
  * **tg**: رابط‌های ترمینال متن‌باز

> هر نسخه غیررسمی ممکن است توسط زبان یا ابزار متفاوتی کامپایل شده باشد (مثل Qt + C++, یا حتی Python با PyQt).

---

## 🔚 جمع‌بندی

* تمام زبان‌ها باید به نوعی حالت اجرایی برسند، خواه باینری مستقیم، خواه بایت‌کد.
* در لینوکس فایل‌های اجرایی از طریق هدر توسط کرنل و loader مدیریت می‌شوند.
* باینری یعنی فایل دودویی برای اجرای مستقیم؛ این در مفسرها کاربرد ندارد ولی خود مفسر یک باینری است.
* پکیج قالب توزیع برنامه است، و از برنامه عام‌تر است.
* فایل‌های `.apk` در اندروید شامل DEX هستند که توسط ماشین ART اجرا می‌شوند.
* فایل اجرایی بدون پسوند توسط هدر شناسایی می‌شود و مستقیماً توسط کرنل و loader اجرا می‌گردد.
* تلگرام رسمی و غیررسمی لینوکسی هر دو وجود دارند.

---
